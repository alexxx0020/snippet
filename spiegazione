ğŸ§± ARCHITETTURA COMPLETA
ğŸ‘¤ L'utente fa login â†’ invia username e password

âœ… Se le credenziali sono giuste, il server crea un JWT (con dati tipo username, ruolo, scadenza)

ğŸ“¬ Il client salva il token e lo invia in ogni richiesta come header Authorization: Bearer <token>

ğŸ§ª Spring intercetta ogni richiesta, verifica il token tramite un filtro (JwtFilter)

ğŸ” Se il token Ã¨ valido, Spring "ricorda" l'utente per quella richiesta e applica le autorizzazioni

ğŸ“Œ STEP 1 â€” JwtUtil.java: Gestione token
Questa classe si occupa di:
Creare un token
Verificarlo
Estrarre dati da esso
ğŸ” Analisi riga per riga

private static final String SECRET_KEY = "SuperSegreta2025";
ğŸ” Chiave segreta per firmare il token.
Chi ce lâ€™ha, puÃ² creare token validi. Non va mai condivisa! (di solito Ã¨ in application.properties)

private final Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);
private final JWTVerifier verifier = JWT.require(algorithm).build();
Algorithm.HMAC256: Algoritmo di firma (qui con SHA-256 e chiave)

JWTVerifier: oggetto che puÃ² verificare la firma e la validitÃ  di un token


public String generateToken(UserDetails userDetails)
ğŸ”§ Crea un token firmato contenente:

subject = username

claim = ruolo

iat = data creazione

exp = data scadenza

String role = userDetails.getAuthorities().iterator().next().getAuthority();
ğŸ‘¤ Estrai il ruolo dellâ€™utente (es. ROLE_ADMIN)

return JWT.create()
    .withSubject(userDetails.getUsername())
    .withClaim("role", role)
    .withIssuedAt(new Date())
    .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION))
    .sign(algorithm);
ğŸ“¦ Costruisce e firma il token JWT.

public boolean isTokenValid(String token, String username)
âœ… Verifica:

Che il token contenga lo username corretto

Che non sia scaduto

Che la firma sia valida

ğŸ“Œ STEP 2 â€” JwtFilter.java: Intercetta ogni richiesta
Estende OncePerRequestFilter = eseguito una volta per richiesta.

ğŸ” Cosa fa?

String header = request.getHeader("Authorization");
ğŸ‘‰ Legge lâ€™header Authorization: Bearer <token>

if (header != null && header.startsWith("Bearer ")) {
    String token = header.substring(7); // taglia "Bearer "

String username = jwtUtil.extractUsername(token);
ğŸ“¤ Legge lo username dal token

UserDetails userDetails = userDetailsService.loadUserByUsername(username);
ğŸ” Ricarica lâ€™utente dal DB/in-memory per confrontarlo con il token

UsernamePasswordAuthenticationToken authToken =
    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
SecurityContextHolder.getContext().setAuthentication(authToken);
ğŸ” Qui "inietti" lâ€™utente nel SecurityContext di Spring, rendendolo autenticato per questa richiesta.

ğŸ“Œ STEP 3 â€” SecurityConfig.java: Configurazione di Spring Security
Questa classe dice a Spring:

ğŸ”“ Quali endpoint sono pubblici (permitAll())

ğŸ”’ Quali endpoint richiedono autenticazione

â• Quali ruoli sono richiesti per certi path

ğŸ§¼ Come trattare CORS e CSRF

â• Aggiunge il tuo JwtFilter nel meccanismo di sicurezza


.requestMatchers("/api/login").permitAll()
â¡ï¸ /api/login puÃ² essere raggiunto senza autenticazione

.anyRequest().authenticated()
ğŸ” Tutto il resto richiede un token JWT valido

.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
ğŸ“Œ Inserisce il tuo filtro prima di quello standard che aspetta una form login.

ğŸ“Œ STEP 4 â€” LoginController.java: Autenticazione
Espone l'endpoint:

POST /api/login

authManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
ğŸ” Chiede a Spring Security di verificare username + password.

String token = jwtUtil.generateToken(user);
âœ… Se tutto va bene, crea un JWT

return ResponseEntity.ok(Map.of("token", token));
ğŸ“¤ Restituisce il token come JSON

ğŸ“Œ STEP 5 â€” UserDetailsService
Dove sta la logica per caricare lâ€™utente?
Spring usa un bean di tipo UserDetailsService.

Esempio:

@Service
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository repo) {
        this.userRepository = repo;
    }

    @Override
    public UserDetails loadUserByUsername(String username) {
        return userRepository.findByUsername(username)
               .orElseThrow(() -> new UsernameNotFoundException("Not found"));
    }
}
ğŸ”„ Come funziona tutto insieme?
L'utente fa login â†’ riceve token JWT

Ogni richiesta include Authorization: Bearer <token>

JwtFilter intercetta, verifica e "autentica" lâ€™utente

SecurityContext contiene lâ€™utente â†’ Spring puÃ² applicare i @PreAuthorize(...)

Se non hai un token valido â†’ 403 Forbidden
